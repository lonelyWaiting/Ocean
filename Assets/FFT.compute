// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Radix008A_CS
#pragma kernel Radix008A_CS2

#define HALF_SQRT_2 0.70710678118654752440084436210485f
#define PI 3.14159274

#define THREAD_NUM 128

uint thread_count;
uint istride;
uint ostride;
uint pstride;
float phase_base;

StructuredBuffer<float2>    src;
RWStructuredBuffer<float2>  dst;

void FT_x_8(inout float2 a, inout float2 b, float x)
{
    float sin_n_8 = sin(PI * x / 4);
    float cos_n_8 = cos(PI * x / 4);

    float oax = a.x, oay = a.y;
    a.x = a.x + cos_n_8 * b.x + sin_n_8 * b.y;
    a.y = a.y - sin_n_8 * b.x + cos_n_8 * b.y;

    float obx = b.x;
    b.x = oax - cos_n_8 * b.x - sin_n_8 * b.y;
    b.y = oay + sin_n_8 * obx - cos_n_8 * b.y;
}

void FFT_8(inout float2 D[8])
{
    FT_x_8(D[0], D[4], 0);
    FT_x_8(D[2], D[6], 0);
    FT_x_8(D[1], D[5], 0);
    FT_x_8(D[3], D[7], 0);

    FT_x_8(D[0], D[2], 0);
    FT_x_8(D[4], D[6], 2);
    FT_x_8(D[1], D[3], 0);
    FT_x_8(D[5], D[7], 2);

    FT_x_8(D[0], D[1], 0);
    FT_x_8(D[4], D[5], 1);
    FT_x_8(D[2], D[3], 2);
    FT_x_8(D[6], D[7], 3);
}

#define COS_PI_4_16 0.70710678118654752440084436210485f
#define TWIDDLE_1_8 COS_PI_4_16, -COS_PI_4_16
#define TWIDDLE_3_8 -COS_PI_4_16, -COS_PI_4_16

// a + W^0_N*b   = a + b
// a + W^(N/2)_N = a - b
void FT2(inout float2 a, inout float2 b)
{
    float t;

    t = a.x;
    a.x += b.x;
    b.x = t - b.x;

    t = a.y;
    a.y += b.y;
    b.y = t - b.y;
}

void CMUL_forward(inout float2 a, float bx, float by)
{
    float t = a.x;
    a.x = t * bx - a.y * by;
    a.y = t * by + a.y * bx;
}

// W^2_8 = e^(-i*2*\pi*2/8) = cos(-\pi/2) + i*sin(-\pi/2) = -i
// W^6_8 = -W^2_8 = i
// a + W^2_8 * b = a - i*b = (a.x + b.y , a.y - b.x)
// a + W^6_8 * b = a + i*b = (a.x - b.y , a.y + b.x)
void UPD_forward(inout float2 a, inout float2 b)
{
    float A = a.x;
    float B = b.y;

    a.x += b.y;
    b.y = a.y + b.x;
    a.y -= b.x;
    b.x = A - B;
}

void FFT_forward_4(inout float2 D[8])
{
    FT2(D[0], D[2]);
    FT2(D[1], D[3]);
    FT2(D[0], D[1]);

    UPD_forward(D[2], D[3]);
}

// 执行一个完整的8-FFT
void FFT_forward_8(inout float2 D[8])
{
    FT2(D[0], D[4]);
    FT2(D[1], D[5]);
    FT2(D[2], D[6]);
    FT2(D[3], D[7]);

    UPD_forward(D[4], D[6]);
    UPD_forward(D[5], D[7]);

    CMUL_forward(D[5], TWIDDLE_1_8);
    CMUL_forward(D[7], TWIDDLE_3_8);

    FFT_forward_4(D);
    FT2(D[4], D[5]);
    FT2(D[6], D[7]);
}

// (d.x+i*d.y)*(cos(phase)+isin(phase))
// d.x * cos(phase) - d.y * sin(phase)
// d.y * cos(phase) + d.x * sin(phase)
void TWIDDLE(inout float2 d, float phase)
{
    float tx, ty;
    tx = sin(phase);
    ty = cos(phase);

    float t = d.x;
    d.x = t * tx - d.y * ty;
    d.y = t * ty + d.y * tx;
}

void TWIDDLE_8(inout float2 D[8], float phase)
{
    TWIDDLE(D[4], 1 * phase);
    TWIDDLE(D[4], 1 * phase);
    TWIDDLE(D[2], 2 * phase);
    TWIDDLE(D[6], 3 * phase);
    TWIDDLE(D[1], 4 * phase);
    TWIDDLE(D[5], 5 * phase);
    TWIDDLE(D[3], 6 * phase);
    TWIDDLE(D[7], 7 * phase);
}

[numthreads(THREAD_NUM, 1, 1)]
void Radix008A_CS(uint3 thread_id : SV_DispatchThreadID)
{
    if (thread_id.x >= thread_count)
        return;

    float2 D[8];

    uint imod  = thread_id.x & (istride - 1);
    uint iaddr = ((thread_id.x - imod) << 3) + imod;
    for (int i = 0; i < 8; i++)
        D[i] = src[iaddr + i * istride];

    //FFT_8(D);
    FFT_forward_8(D);
    uint p = thread_id.x & (istride - pstride);
    float phase = phase_base * (float) p;
    TWIDDLE_8(D, phase);

    uint omod = thread_id.x & (ostride - 1);
    uint oaddr = ((thread_id.x - omod) << 3) + omod;
    dst[oaddr + 0 * ostride] = D[0];
    dst[oaddr + 1 * ostride] = D[4];
    dst[oaddr + 2 * ostride] = D[2];
    dst[oaddr + 3 * ostride] = D[6];
    dst[oaddr + 4 * ostride] = D[1];
    dst[oaddr + 5 * ostride] = D[5];
    dst[oaddr + 6 * ostride] = D[3];
    dst[oaddr + 7 * ostride] = D[7];
}

[numthreads(THREAD_NUM, 1, 1)]
void Radix008A_CS2(uint3 thread_id : SV_DispatchThreadID)
{
    if (thread_id.x >= thread_count)
        return;

    float2 D[8];

    uint iaddr = thread_id.x << 3;
    for (int i = 0; i < 8; i++)
        D[i] = src[iaddr + i];

    //FFT_8(D);
    FFT_forward_8(D);

    uint omod = thread_id.x & (ostride - 1);
    uint oaddr = ((thread_id.x - omod) << 3) + omod;
    dst[oaddr + 0 * ostride] = D[0];
    dst[oaddr + 1 * ostride] = D[4];
    dst[oaddr + 2 * ostride] = D[2];
    dst[oaddr + 3 * ostride] = D[6];
    dst[oaddr + 4 * ostride] = D[1];
    dst[oaddr + 5 * ostride] = D[5];
    dst[oaddr + 6 * ostride] = D[3];
    dst[oaddr + 7 * ostride] = D[7];
}